1. O mundo (região/cidade) tem eventos objetivos (“chegada do Papai Noel hoje”).

2. Cada NPC tem personalidade + rotina (quem liga/quem odeia/quem trabalha/quem comenta).

3. Cada jogador tem “o que já viu/foi dito” (pra evitar o NPC repetir a mesma fala todo minuto).

Abaixo vai um padrão bem redondo pra SQLite.
________________


1) Tabelas base
regions
Representa cidade/região (Pewter City, Route 3, etc.)
   * region_id (PK) — pewter_city

   * name — “Pewter City”

   * timezone — “America/Sao_Paulo” (ou por mapa)

   * lore_summary — 1 parágrafo de contexto local

world_events
Evento do mundo vinculado a uma região (o “fato”)
      * event_id (PK)

      * region_id (FK)

      * title — “Chegada do Papai Noel”

      * description — texto curto, factual

      * starts_at, ends_at (datetime)

      * priority (0–10) — impacto

      * visibility (public, rumor, secret)

      * tags — JSON: ["natal","multidão","promoção"]

      * status (scheduled, active, ended, cancelled)

      * created_by (system, gm, script)

Boa prática: evento é “o que acontece”, não “o que o NPC pensa”.
________________


2) NPCs e comportamento
npcs
         * npc_id

         * region_id (onde ele “mora/trabalha” por padrão)

         * name

         * role — “pokemart_clerk”

         * persona_prompt — texto fixo (voz/limites)

         * traits_json — ex.: { "cheerful": 0.8, "greedy": 0.2, "talkative": 0.6 }

npc_event_policy
Define como o NPC reage a tipos de evento (sem precisar hardcode)
            * npc_id

            * tag — “natal”, “perigo”, “promoção”

            * interest (-3 a +3) — quanto importa pra ele

            * tone (happy, neutral, annoyed, fearful)

            * comment_chance (0–1) — chance de ele comentar espontaneamente

Exemplo:
               * Comerciante: promoção +3, multidão +2, perigo -2

               * Guarda: perigo +3, multidão +2

________________


3) Evitar repetição: “quem já sabe do quê”
player_event_exposure
Rastreia se o jogador já foi exposto ao evento por aquele NPC (pra não repetir)
                  * player_id

                  * npc_id

                  * event_id

                  * first_mentioned_at

                  * last_mentioned_at

                  * mention_count

Regra simples:
                     * se mention_count >= 1 e nada mudou no evento, NPC só volta a mencionar se:

                        * jogador perguntar, ou

                        * evento entrou em fase nova (ex.: “agora começou”), ou

                        * passou um tempo (cooldown)

________________


4) “Fases” do evento (o segredo pra parecer vivo)
Um mesmo evento pode ter fases, e NPC reage diferente em cada uma:
world_event_phases
                           * phase_id

                           * event_id

                           * phase_name — “pré-chegada”, “chegada”, “pico”, “encerramento”

                           * starts_at, ends_at

                           * phase_notes — fatos úteis (“ruas lotadas”, “promo no PokéMart”)

Quando muda a fase, você permite nova fala sem parecer repetição.
________________


5) Como isso entra no prompt do NPC (muito importante)
Na hora de responder um chat, você monta:
Contexto fixo
                              * Persona do NPC + regras (ex.: comerciante, horário de trabalho)

Contexto local (região)
                                 * regions.lore_summary

Eventos relevantes “AGORA”
Seleciona por:
                                    * mesma region_id

                                    * status = active (ou scheduled se começa em breve)

                                    * ordena por priority e proximidade de horário

E injeta em um bloco tipo:
EVENTOS LOCAIS (FATOS)
                                       * [evento_id] Título — fase atual — 1 linha do que está acontecendo

                                       * Regras: “Você pode comentar sobre isso se fizer sentido”

Restrições anti-lixo
                                          * “Não repita evento se já foi mencionado recentemente (veja exposure)”

                                          * “Só comenta espontaneamente se comment_chance bater e for natural”

________________


6) Lógica de decisão: quando o NPC comenta um evento?
Use uma regra simples (funciona muito bem):
O NPC comenta se:
                                             * o evento está ativo e é público

                                             * interest alto (por tag) ou priority alto

                                             * não está em cooldown (player_event_exposure)

                                             * e a conversa tem abertura (“bom dia”, “como vai”, “o que tem de novo”, etc.)

Se o jogador perguntar:
                                                * “o que está acontecendo na cidade?”
Aí você ignora o comment_chance e lista os 1–3 eventos mais relevantes.

________________


7) Exemplo: “Chegada do Papai Noel” em Pewter City
Evento:
                                                   * title: Chegada do Papai Noel

                                                   * tags: natal, multidão, promoção

                                                   * phases:

                                                      * pré-chegada: “enfeites e música”

                                                      * chegada: “praça lotada”

                                                      * pico: “fila enorme, promoções”

                                                      * encerramento: “cidade mais calma”

Comerciante do PokéMart:
                                                         * policy: natal (+1, feliz), promoção (+3, animado), multidão (+2, prático)

Primeira vez com o jogador:
“Bom dia! Hoje a praça vai ficar cheia — parece que o ‘Papai Noel’ chega mais tarde. Se for sair, leve algumas Potions… e olha, estamos com uma promo especial.”
Depois de já ter dito:
                                                            * ele não repete, a menos que:

                                                               * a fase mude para “chegada” (agora aconteceu)

                                                               * ou o jogador pergunte.

________________


8) O que você ganha com esse padrão
                                                                  * “Conhecimento local” fica separado de conversa.

                                                                  * NPC reage de forma consistente via policy (tags → interesse/tom).

                                                                  * Você evita repetição com player_event_exposure.

                                                                  * Eventos podem ser criados por script/GM e todo mundo “sente” o mundo mudar.


PRAGMA foreign_keys = ON;


-- ---------------------------
-- REGIÕES / CIDADES
-- ---------------------------
CREATE TABLE IF NOT EXISTS regions (
  region_id      TEXT PRIMARY KEY,     -- ex: 'pewter_city'
  name           TEXT NOT NULL,         -- ex: 'Pewter City'
  timezone       TEXT NOT NULL DEFAULT 'America/Sao_Paulo',
  lore_summary   TEXT NOT NULL DEFAULT '',
  created_at     TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at     TEXT NOT NULL DEFAULT (datetime('now'))
);


-- ---------------------------
-- EVENTOS DO MUNDO (FATOS)
-- ---------------------------
CREATE TABLE IF NOT EXISTS world_events (
  event_id       TEXT PRIMARY KEY,      -- UUID ou string
  region_id      TEXT NOT NULL,
  title          TEXT NOT NULL,
  description    TEXT NOT NULL DEFAULT '',
  starts_at      TEXT NOT NULL,         -- ISO / datetime('now') style
  ends_at        TEXT NOT NULL,
  priority       INTEGER NOT NULL DEFAULT 5,    -- 0..10
  visibility     TEXT NOT NULL DEFAULT 'public' -- public|rumor|secret
                CHECK (visibility IN ('public','rumor','secret')),
  tags_json      TEXT NOT NULL DEFAULT '[]',    -- JSON array string
  status         TEXT NOT NULL DEFAULT 'scheduled'
                CHECK (status IN ('scheduled','active','ended','cancelled')),
  created_by     TEXT NOT NULL DEFAULT 'system',
  created_at     TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at     TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY (region_id) REFERENCES regions(region_id) ON DELETE CASCADE
);


CREATE INDEX IF NOT EXISTS idx_world_events_region_time
ON world_events(region_id, starts_at, ends_at, status);


CREATE INDEX IF NOT EXISTS idx_world_events_status
ON world_events(status);


-- ---------------------------
-- FASES DO EVENTO (pra parecer vivo)
-- ---------------------------
CREATE TABLE IF NOT EXISTS world_event_phases (
  phase_id       TEXT PRIMARY KEY,
  event_id       TEXT NOT NULL,
  phase_name     TEXT NOT NULL,         -- ex: 'pre-chegada', 'chegada', ...
  starts_at      TEXT NOT NULL,
  ends_at        TEXT NOT NULL,
  phase_notes    TEXT NOT NULL DEFAULT '',
  created_at     TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY (event_id) REFERENCES world_events(event_id) ON DELETE CASCADE
);


CREATE INDEX IF NOT EXISTS idx_event_phases_event_time
ON world_event_phases(event_id, starts_at, ends_at);


-- ---------------------------
-- NPCs
-- ---------------------------
CREATE TABLE IF NOT EXISTS npcs (
  npc_id         TEXT PRIMARY KEY,      -- ex: 'pewter_mart_clerk'
  region_id      TEXT NOT NULL,
  name           TEXT NOT NULL,
  role           TEXT NOT NULL DEFAULT '',
  persona_prompt TEXT NOT NULL DEFAULT '',
  traits_json    TEXT NOT NULL DEFAULT '{}',    -- JSON object string
  created_at     TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at     TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY (region_id) REFERENCES regions(region_id) ON DELETE CASCADE
);


CREATE INDEX IF NOT EXISTS idx_npcs_region
ON npcs(region_id);


-- ---------------------------
-- POLÍTICA DO NPC PARA EVENTOS (por tag)
-- ---------------------------
CREATE TABLE IF NOT EXISTS npc_event_policy (
  npc_id         TEXT NOT NULL,
  tag            TEXT NOT NULL,          -- ex: 'natal', 'perigo'
  interest       INTEGER NOT NULL DEFAULT 0,  -- -3..+3
  tone           TEXT NOT NULL DEFAULT 'neutral'
                CHECK (tone IN ('happy','neutral','annoyed','fearful','excited','serious')),
  comment_chance REAL NOT NULL DEFAULT 0.4,   -- 0..1
  PRIMARY KEY (npc_id, tag),
  FOREIGN KEY (npc_id) REFERENCES npcs(npc_id) ON DELETE CASCADE
);


-- ---------------------------
-- EXPOSIÇÃO: o que o jogador já ouviu desse NPC sobre o evento
-- ---------------------------
CREATE TABLE IF NOT EXISTS player_event_exposure (
  player_id          TEXT NOT NULL,
  npc_id             TEXT NOT NULL,
  event_id           TEXT NOT NULL,
  first_mentioned_at TEXT NOT NULL DEFAULT (datetime('now')),
  last_mentioned_at  TEXT NOT NULL DEFAULT (datetime('now')),
  mention_count      INTEGER NOT NULL DEFAULT 1,
  last_phase_id      TEXT,               -- pra permitir “nova fala” quando a fase muda
  PRIMARY KEY (player_id, npc_id, event_id),
  FOREIGN KEY (npc_id) REFERENCES npcs(npc_id) ON DELETE CASCADE,
  FOREIGN KEY (event_id) REFERENCES world_events(event_id) ON DELETE CASCADE
);


CREATE INDEX IF NOT EXISTS idx_exposure_lookup
ON player_event_exposure(player_id, npc_id, last_mentioned_at);


3) Node (CommonJS) — DB + Serviço de Eventos
3.1 Instalar dependência SQLite


Recomendo better-sqlite3 (simples e rápido):


npm i better-sqlite3




Se der algum problema de build no Windows, me avisa que eu te passo versão com sqlite3 (async).


3.2 services/db.js
// services/db.js
const path = require('path');
const fs = require('fs');
const Database = require('better-sqlite3');


const DB_PATH = process.env.SQLITE_PATH || path.join(__dirname, '..', 'db', 'game.sqlite');
const SCHEMA_PATH = path.join(__dirname, '..', 'db', 'schema.sql');


let db;


function getDb() {
  if (!db) {
    db = new Database(DB_PATH);
    db.pragma('journal_mode = WAL');
    db.pragma('foreign_keys = ON');
  }
  return db;
}


function runSchema() {
  const database = getDb();
  const sql = fs.readFileSync(SCHEMA_PATH, 'utf-8');
  database.exec(sql);
}


function runSeed(seedPath) {
  const database = getDb();
  const sql = fs.readFileSync(seedPath, 'utf-8');
  database.exec(sql);
}


module.exports = { getDb, runSchema, runSeed, DB_PATH };


3.3 services/events.service.js


Aqui estão as funções que você pediu:


getActiveEvents(regionId, nowIso)


getCurrentPhase(eventId, nowIso)


getRelevantEventsForNpc(npcId, playerId, nowIso, limit)


shouldMentionEvent(...) (com cooldown + fase)


recordEventMention(...)


// services/events.service.js
const { getDb } = require('./db');


function isoNow() {
  return new Date().toISOString();
}


function getActiveEvents(regionId, nowIso = isoNow()) {
  const db = getDb();
  // Eventos ativos (ou scheduled que já começou por horário, se quiser)
  const stmt = db.prepare(`
    SELECT *
    FROM world_events
    WHERE region_id = ?
      AND status IN ('active','scheduled')
      AND starts_at <= ?
      AND ends_at >= ?
      AND visibility = 'public'
    ORDER BY priority DESC, starts_at ASC
  `);
  return stmt.all(regionId, nowIso, nowIso);
}


function getCurrentPhase(eventId, nowIso = isoNow()) {
  const db = getDb();
  const stmt = db.prepare(`
    SELECT *
    FROM world_event_phases
    WHERE event_id = ?
      AND starts_at <= ?
      AND ends_at >= ?
    ORDER BY starts_at DESC
    LIMIT 1
  `);
  return stmt.get(eventId, nowIso, nowIso) || null;
}


function getNpcPolicyForTags(npcId, tags) {
  const db = getDb();
  if (!tags || tags.length === 0) return [];


  // Buscar policy só pras tags do evento
  const placeholders = tags.map(() => '?').join(',');
  const stmt = db.prepare(`
    SELECT tag, interest, tone, comment_chance
    FROM npc_event_policy
    WHERE npc_id = ?
      AND tag IN (${placeholders})
  `);
  return stmt.all(npcId, ...tags);
}


function getExposure(playerId, npcId, eventId) {
  const db = getDb();
  const stmt = db.prepare(`
    SELECT *
    FROM player_event_exposure
    WHERE player_id = ? AND npc_id = ? AND event_id = ?
  `);
  return stmt.get(playerId, npcId, eventId) || null;
}


function recordEventMention(playerId, npcId, eventId, phaseId = null, nowIso = isoNow()) {
  const db = getDb();
  const existing = getExposure(playerId, npcId, eventId);


  if (!existing) {
    const ins = db.prepare(`
      INSERT INTO player_event_exposure
        (player_id, npc_id, event_id, first_mentioned_at, last_mentioned_at, mention_count, last_phase_id)
      VALUES (?, ?, ?, ?, ?, 1, ?)
    `);
    ins.run(playerId, npcId, eventId, nowIso, nowIso, phaseId);
    return;
  }


  const upd = db.prepare(`
    UPDATE player_event_exposure
    SET last_mentioned_at = ?,
        mention_count = mention_count + 1,
        last_phase_id = COALESCE(?, last_phase_id)
    WHERE player_id = ? AND npc_id = ? AND event_id = ?
  `);
  upd.run(nowIso, phaseId, playerId, npcId, eventId);
}


/**
 * Decide se o NPC deve mencionar espontaneamente.
 * Regras:
 * - Se nunca mencionou: pode mencionar.
 * - Se já mencionou: só menciona se a fase mudou OU passou o cooldown.
 * - Aplica um "comment_chance" baseado na policy do NPC (por tags).
 */
function shouldMentionEvent({ playerId, npcId, event, phase, nowIso = isoNow(), cooldownMinutes = 30 }) {
  const exposure = getExposure(playerId, npcId, event.event_id);


  const tags = safeParseJsonArray(event.tags_json);
  const policyRows = getNpcPolicyForTags(npcId, tags);


  // score simples de relevância (quanto o NPC se importa)
  const interestSum = policyRows.reduce((acc, r) => acc + (r.interest || 0), 0);


  // Se o NPC não tem policy nenhuma pra essas tags,
  // ainda pode comentar se priority for alta.
  const baseChance =
    policyRows.length > 0
      ? clamp01(avg(policyRows.map(r => r.comment_chance)))
      : (event.priority >= 8 ? 0.35 : 0.10);


  // Ajuste por interesse e prioridade
  let chance = baseChance;
  chance += (interestSum * 0.06);         // cada ponto de interesse muda ~6%
  chance += ((event.priority - 5) * 0.03); // prioridade sobe chance


  chance = clamp01(chance);


  // Regra de repetição
  if (exposure) {
    const last = Date.parse(exposure.last_mentioned_at);
    const now = Date.parse(nowIso);
    const minutes = (now - last) / 60000;


    const phaseChanged = (phase?.phase_id && exposure.last_phase_id && phase.phase_id !== exposure.last_phase_id)
      || (phase?.phase_id && !exposure.last_phase_id); // se nunca guardou fase


    if (!phaseChanged && minutes < cooldownMinutes) {
      return { ok: false, reason: 'cooldown', chance, interestSum };
    }
  }


  // sorteio (spontâneo)
  const roll = Math.random();
  const ok = roll < chance;


  return { ok, reason: ok ? 'roll_pass' : 'roll_fail', chance, interestSum };
}


/**
 * Retorna eventos "bons" para colocar no prompt do NPC,
 * já com fase atual e policy calculada.
 */
function getRelevantEventsForNpc({ npcId, playerId, regionId, nowIso = isoNow(), limit = 3 }) {
  const events = getActiveEvents(regionId, nowIso);


  const enriched = events.map(ev => {
    const phase = getCurrentPhase(ev.event_id, nowIso);
    const tags = safeParseJsonArray(ev.tags_json);
    const policy = getNpcPolicyForTags(npcId, tags);


    // qual tom prevalece? (pega maior interest)
    let tone = 'neutral';
    if (policy.length) {
      const best = [...policy].sort((a,b) => (b.interest||0) - (a.interest||0))[0];
      tone = best.tone || 'neutral';
    }


    return { event: ev, phase, tone, tags, policy };
  });


  // ordena por prioridade e proximidade
  enriched.sort((a,b) => (b.event.priority - a.event.priority) || (a.event.starts_at.localeCompare(b.event.starts_at)));


  return enriched.slice(0, limit);
}


// helpers
function safeParseJsonArray(str) {
  try {
    const v = JSON.parse(str || '[]');
    return Array.isArray(v) ? v : [];
  } catch { return []; }
}
function clamp01(x) { return Math.max(0, Math.min(1, x)); }
function avg(arr) { return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }


module.exports = {
  getActiveEvents,
  getCurrentPhase,
  getRelevantEventsForNpc,
  shouldMentionEvent,
  recordEventMention
};


4) Inicialização do banco (schema + seed)


No seu server.js, depois do dotenv, rode schema/seed uma vez no boot.


require('dotenv').config();


const path = require('path');
const { runSchema, runSeed } = require('./services/db');


runSchema();
runSeed(path.join(__dirname, 'db', 'seed.sql'));


5) Como usar isso no seu /chat (exemplo bem direto)


Antes de chamar o Ollama, você busca eventos relevantes e decide se comenta.


const { getRelevantEventsForNpc, shouldMentionEvent, recordEventMention } = require('../services/events.service');


const npcId = 'pewter_mart_clerk';
const regionId = 'pewter_city';
const playerId = req.body.playerId || 'player_test_001';


const relevant = getRelevantEventsForNpc({ npcId, playerId, regionId, limit: 3 });


let eventBlurb = '';
for (const r of relevant) {
  const decision = shouldMentionEvent({ playerId, npcId, event: r.event, phase: r.phase, cooldownMinutes: 30 });
  if (decision.ok) {
    // registra para não repetir
    recordEventMention(playerId, npcId, r.event.event_id, r.phase?.phase_id || null);
    eventBlurb += `- ${r.event.title} (${r.phase?.phase_name || 'em andamento'}): ${r.phase?.phase_notes || r.event.description}\n`;
    break; // menciona 1 evento por vez (fica natural)
  }
}


// Aí injeta isso no prompt do NPC:
const system = `
Você é o atendente do PokéMart de Pewter City e está trabalhando.
Se houver eventos locais, você pode comentá-los brevemente, se for natural.


EVENTOS LOCAIS (FATOS):
${eventBlurb || '(nenhum relevante agora)'}
`.trim();
3) Node (CommonJS) — DB + Serviço de Eventos
3.1 Instalar dependência SQLite
Recomendo better-sqlite3 (simples e rápido):
npm i better-sqlite3


Se der algum problema de build no Windows, me avisa que eu te passo versão com sqlite3 (async).
________________


3.2 services/db.js
// services/db.js
const path = require('path');
const fs = require('fs');
const Database = require('better-sqlite3');


const DB_PATH = process.env.SQLITE_PATH || path.join(__dirname, '..', 'db', 'game.sqlite');
const SCHEMA_PATH = path.join(__dirname, '..', 'db', 'schema.sql');


let db;


function getDb() {
  if (!db) {
    db = new Database(DB_PATH);
    db.pragma('journal_mode = WAL');
    db.pragma('foreign_keys = ON');
  }
  return db;
}


function runSchema() {
  const database = getDb();
  const sql = fs.readFileSync(SCHEMA_PATH, 'utf-8');
  database.exec(sql);
}


function runSeed(seedPath) {
  const database = getDb();
  const sql = fs.readFileSync(seedPath, 'utf-8');
  database.exec(sql);
}


module.exports = { getDb, runSchema, runSeed, DB_PATH };


________________


3.3 services/events.service.js
Aqui estão as funções que você pediu:
                                                                     * getActiveEvents(regionId, nowIso)

                                                                     * getCurrentPhase(eventId, nowIso)

                                                                     * getRelevantEventsForNpc(npcId, playerId, nowIso, limit)

                                                                     * shouldMentionEvent(...) (com cooldown + fase)

                                                                     * recordEventMention(...)

// services/events.service.js
const { getDb } = require('./db');


function isoNow() {
  return new Date().toISOString();
}


function getActiveEvents(regionId, nowIso = isoNow()) {
  const db = getDb();
  // Eventos ativos (ou scheduled que já começou por horário, se quiser)
  const stmt = db.prepare(`
    SELECT *
    FROM world_events
    WHERE region_id = ?
      AND status IN ('active','scheduled')
      AND starts_at <= ?
      AND ends_at >= ?
      AND visibility = 'public'
    ORDER BY priority DESC, starts_at ASC
  `);
  return stmt.all(regionId, nowIso, nowIso);
}


function getCurrentPhase(eventId, nowIso = isoNow()) {
  const db = getDb();
  const stmt = db.prepare(`
    SELECT *
    FROM world_event_phases
    WHERE event_id = ?
      AND starts_at <= ?
      AND ends_at >= ?
    ORDER BY starts_at DESC
    LIMIT 1
  `);
  return stmt.get(eventId, nowIso, nowIso) || null;
}


function getNpcPolicyForTags(npcId, tags) {
  const db = getDb();
  if (!tags || tags.length === 0) return [];


  // Buscar policy só pras tags do evento
  const placeholders = tags.map(() => '?').join(',');
  const stmt = db.prepare(`
    SELECT tag, interest, tone, comment_chance
    FROM npc_event_policy
    WHERE npc_id = ?
      AND tag IN (${placeholders})
  `);
  return stmt.all(npcId, ...tags);
}


function getExposure(playerId, npcId, eventId) {
  const db = getDb();
  const stmt = db.prepare(`
    SELECT *
    FROM player_event_exposure
    WHERE player_id = ? AND npc_id = ? AND event_id = ?
  `);
  return stmt.get(playerId, npcId, eventId) || null;
}


function recordEventMention(playerId, npcId, eventId, phaseId = null, nowIso = isoNow()) {
  const db = getDb();
  const existing = getExposure(playerId, npcId, eventId);


  if (!existing) {
    const ins = db.prepare(`
      INSERT INTO player_event_exposure
        (player_id, npc_id, event_id, first_mentioned_at, last_mentioned_at, mention_count, last_phase_id)
      VALUES (?, ?, ?, ?, ?, 1, ?)
    `);
    ins.run(playerId, npcId, eventId, nowIso, nowIso, phaseId);
    return;
  }


  const upd = db.prepare(`
    UPDATE player_event_exposure
    SET last_mentioned_at = ?,
        mention_count = mention_count + 1,
        last_phase_id = COALESCE(?, last_phase_id)
    WHERE player_id = ? AND npc_id = ? AND event_id = ?
  `);
  upd.run(nowIso, phaseId, playerId, npcId, eventId);
}


/**
 * Decide se o NPC deve mencionar espontaneamente.
 * Regras:
 * - Se nunca mencionou: pode mencionar.
 * - Se já mencionou: só menciona se a fase mudou OU passou o cooldown.
 * - Aplica um "comment_chance" baseado na policy do NPC (por tags).
 */
function shouldMentionEvent({ playerId, npcId, event, phase, nowIso = isoNow(), cooldownMinutes = 30 }) {
  const exposure = getExposure(playerId, npcId, event.event_id);


  const tags = safeParseJsonArray(event.tags_json);
  const policyRows = getNpcPolicyForTags(npcId, tags);


  // score simples de relevância (quanto o NPC se importa)
  const interestSum = policyRows.reduce((acc, r) => acc + (r.interest || 0), 0);


  // Se o NPC não tem policy nenhuma pra essas tags,
  // ainda pode comentar se priority for alta.
  const baseChance =
    policyRows.length > 0
      ? clamp01(avg(policyRows.map(r => r.comment_chance)))
      : (event.priority >= 8 ? 0.35 : 0.10);


  // Ajuste por interesse e prioridade
  let chance = baseChance;
  chance += (interestSum * 0.06);         // cada ponto de interesse muda ~6%
  chance += ((event.priority - 5) * 0.03); // prioridade sobe chance


  chance = clamp01(chance);


  // Regra de repetição
  if (exposure) {
    const last = Date.parse(exposure.last_mentioned_at);
    const now = Date.parse(nowIso);
    const minutes = (now - last) / 60000;


    const phaseChanged = (phase?.phase_id && exposure.last_phase_id && phase.phase_id !== exposure.last_phase_id)
      || (phase?.phase_id && !exposure.last_phase_id); // se nunca guardou fase


    if (!phaseChanged && minutes < cooldownMinutes) {
      return { ok: false, reason: 'cooldown', chance, interestSum };
    }
  }


  // sorteio (spontâneo)
  const roll = Math.random();
  const ok = roll < chance;


  return { ok, reason: ok ? 'roll_pass' : 'roll_fail', chance, interestSum };
}


/**
 * Retorna eventos "bons" para colocar no prompt do NPC,
 * já com fase atual e policy calculada.
 */
function getRelevantEventsForNpc({ npcId, playerId, regionId, nowIso = isoNow(), limit = 3 }) {
  const events = getActiveEvents(regionId, nowIso);


  const enriched = events.map(ev => {
    const phase = getCurrentPhase(ev.event_id, nowIso);
    const tags = safeParseJsonArray(ev.tags_json);
    const policy = getNpcPolicyForTags(npcId, tags);


    // qual tom prevalece? (pega maior interest)
    let tone = 'neutral';
    if (policy.length) {
      const best = [...policy].sort((a,b) => (b.interest||0) - (a.interest||0))[0];
      tone = best.tone || 'neutral';
    }


    return { event: ev, phase, tone, tags, policy };
  });


  // ordena por prioridade e proximidade
  enriched.sort((a,b) => (b.event.priority - a.event.priority) || (a.event.starts_at.localeCompare(b.event.starts_at)));


  return enriched.slice(0, limit);
}


// helpers
function safeParseJsonArray(str) {
  try {
    const v = JSON.parse(str || '[]');
    return Array.isArray(v) ? v : [];
  } catch { return []; }
}
function clamp01(x) { return Math.max(0, Math.min(1, x)); }
function avg(arr) { return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }


module.exports = {
  getActiveEvents,
  getCurrentPhase,
  getRelevantEventsForNpc,
  shouldMentionEvent,
  recordEventMention
};


________________


4) Inicialização do banco (schema + seed)
No seu server.js, depois do dotenv, rode schema/seed uma vez no boot.
require('dotenv').config();


const path = require('path');
const { runSchema, runSeed } = require('./services/db');


runSchema();
runSeed(path.join(__dirname, 'db', 'seed.sql'));


________________


5) Como usar isso no seu /chat (exemplo bem direto)
Antes de chamar o Ollama, você busca eventos relevantes e decide se comenta.
const { getRelevantEventsForNpc, shouldMentionEvent, recordEventMention } = require('../services/events.service');


const npcId = 'pewter_mart_clerk';
const regionId = 'pewter_city';
const playerId = req.body.playerId || 'player_test_001';


const relevant = getRelevantEventsForNpc({ npcId, playerId, regionId, limit: 3 });


let eventBlurb = '';
for (const r of relevant) {
  const decision = shouldMentionEvent({ playerId, npcId, event: r.event, phase: r.phase, cooldownMinutes: 30 });
  if (decision.ok) {
    // registra para não repetir
    recordEventMention(playerId, npcId, r.event.event_id, r.phase?.phase_id || null);
    eventBlurb += `- ${r.event.title} (${r.phase?.phase_name || 'em andamento'}): ${r.phase?.phase_notes || r.event.description}\n`;
    break; // menciona 1 evento por vez (fica natural)
  }
}


// Aí injeta isso no prompt do NPC:
const system = `
Você é o atendente do PokéMart de Pewter City e está trabalhando.
Se houver eventos locais, você pode comentá-los brevemente, se for natural.


EVENTOS LOCAIS (FATOS):
${eventBlurb || '(nenhum relevante agora)'}
`.trim();